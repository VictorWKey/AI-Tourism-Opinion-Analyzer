"""
Analizador de Sentimientos usando HuggingFace
===========================================

Este m√≥dulo contiene la l√≥gica para el an√°lisis de sentimientos usando modelos 
preentrenados de HuggingFace Transformers.

Autor: Sistema de An√°lisis de Opiniones Tur√≠sticas
Fecha: 2025
"""

import pandas as pd
from typing import Dict, List, Optional
import warnings
warnings.filterwarnings('ignore')

from .base_sentimientos import ConfiguracionSentimientos

# Importaciones para modelos preentrenados (se importar√°n cuando se necesiten)
try:
    from transformers import pipeline
    TRANSFORMERS_AVAILABLE = True
except ImportError:
    TRANSFORMERS_AVAILABLE = False


class AnalizadorHuggingFace:
    """
    Clase para an√°lisis de sentimientos usando modelos preentrenados de HuggingFace.
    
    Esta clase utiliza modelos de transformers para clasificar texto en sentimientos
    y permite comparar los resultados con clasificaciones basadas en calificaciones.
    """
    
    def __init__(self, modelo_nombre: Optional[str] = None):
        """
        Inicializa el analizador con un modelo preentrenado de HuggingFace.
        
        Args:
            modelo_nombre (str): Nombre del modelo preentrenado a usar
        """
        self.config = ConfiguracionSentimientos()
        self.modelo_nombre = modelo_nombre or self.config.MODELO_HUGGINGFACE_DEFAULT
        self.pipeline = None
        self.modelo_cargado = False
    
    def cargar_modelo(self) -> bool:
        """
        Carga el modelo preentrenado de HuggingFace.
        
        Returns:
            bool: True si el modelo se carg√≥ exitosamente, False en caso contrario
        """
        if not TRANSFORMERS_AVAILABLE:
            print("‚ùå Error: La librer√≠a transformers no est√° disponible")
            print("üí° Instala con: pip install transformers torch")
            return False
        
        try:
            print(f"ü§ñ Cargando modelo: {self.modelo_nombre}")
            print("‚è≥ Esto puede tomar unos momentos la primera vez...")
            
            self.pipeline = pipeline(
                "sentiment-analysis",
                model=self.modelo_nombre,
                return_all_scores=True
            )
            
            self.modelo_cargado = True
            print("‚úÖ Modelo cargado exitosamente")
            print(f"üåç Modelo: {self.modelo_nombre}")
            return True
            
        except Exception as e:
            print(f"‚ùå Error al cargar el modelo: {e}")
            print("üí° Intentando con modelo alternativo...")
            
            try:
                self.pipeline = pipeline("sentiment-analysis", return_all_scores=True)
                self.modelo_cargado = True
                print("‚úÖ Modelo alternativo cargado exitosamente")
                return True
            except Exception as e2:
                print(f"‚ùå Error cr√≠tico: {e2}")
                return False
    
    def mapear_resultado_huggingface(self, resultado: List[Dict]) -> str:
        """
        Mapea el resultado de HuggingFace a nuestras categor√≠as est√°ndar.
        
        Args:
            resultado (List[Dict]): Resultado del modelo de HuggingFace
            
        Returns:
            str: Sentimiento mapeado ('Positivo', 'Neutro', 'Negativo')
        """
        if not resultado:
            return "Neutro"
        
        # Si el resultado es una lista de scores (estructura anidada)
        if isinstance(resultado[0], list):
            scores_list = resultado[0]
        else:
            scores_list = resultado
        
        # Encontrar la etiqueta con mayor probabilidad
        mejor_prediccion = max(scores_list, key=lambda x: x['score'])
        mejor_label = mejor_prediccion['label']
        mejor_score = mejor_prediccion['score']
        
        # Mapeo directo usando la etiqueta con mayor probabilidad
        if mejor_label in self.config.MAPEO_ETIQUETAS_HF:
            return self.config.MAPEO_ETIQUETAS_HF[mejor_label]
        
        # Mapeo de respaldo basado en patrones si no se encuentra mapeo directo
        label_lower = mejor_label.lower()
        if any(pos in label_lower for pos in ['positive', 'pos', '5', '4']):
            return "Positivo"
        elif any(neg in label_lower for neg in ['negative', 'neg', '1', '2']):
            return "Negativo"
        elif any(neu in label_lower for neu in ['neutral', 'neu', '3']):
            return "Neutro"
        else:
            # Si no reconocemos el patr√≥n, usar la probabilidad m√°s alta como criterio
            if mejor_score > 0.6:
                return "Positivo"  # Asumir positivo para scores altos no reconocidos
            else:
                return "Neutro"
    
    def analizar_sentimiento_texto(self, texto: str) -> str:
        """
        Analiza el sentimiento de un texto usando el modelo preentrenado.
        
        Args:
            texto (str): Texto a analizar
            
        Returns:
            str: Sentimiento detectado ('Positivo', 'Neutro', 'Negativo')
        """
        if not self.modelo_cargado:
            print("‚ùå Error: El modelo no ha sido cargado")
            return "Neutro"
        
        if pd.isna(texto) or str(texto).strip() == "":
            return "Neutro"
        
        try:
            # Limitar el texto a 512 caracteres para evitar problemas de memoria
            texto_procesado = str(texto)[:512]
            resultado = self.pipeline(texto_procesado)
            return self.mapear_resultado_huggingface(resultado)
            
        except Exception as e:
            print(f"Error procesando texto: {str(texto)[:50]}... - {e}")
            return "Neutro"
    
    def procesar_dataset_completo(self, df: pd.DataFrame, columna_texto: str = 'TituloReview') -> pd.DataFrame:
        """
        Procesa todo el dataset para obtener sentimientos usando el modelo preentrenado.
        
        Args:
            df (pd.DataFrame): Dataset a procesar
            columna_texto (str): Nombre de la columna que contiene el texto
            
        Returns:
            pd.DataFrame: Dataset con nueva columna 'SentimientoPorHF'
        """
        if not self.modelo_cargado:
            print("‚ùå Error: El modelo no ha sido cargado")
            return df
        
        print(f"üîÑ Procesando sentimientos con HuggingFace para {len(df)} registros...")
        print("‚è≥ Esto puede tomar varios minutos...")
        
        df_resultado = df.copy()
        sentimientos_hf = []
        
        for i, texto in enumerate(df[columna_texto]):
            if i % 25 == 0:  # Progreso cada 25 registros
                print(f"   Procesando registro {i+1}/{len(df)} ({((i+1)/len(df)*100):.1f}%)")
            
            sentimiento = self.analizar_sentimiento_texto(texto)
            sentimientos_hf.append(sentimiento)
        
        df_resultado['SentimientoPorHF'] = sentimientos_hf
        print("‚úÖ Procesamiento con HuggingFace completado")
        
        return df_resultado
    
    def mostrar_ejemplos_discordantes(self, df: pd.DataFrame, n_ejemplos: int = 5):
        """
        Muestra ejemplos donde los dos m√©todos no concuerdan.
        
        Args:
            df (pd.DataFrame): Dataset con ambas columnas de sentimiento
            n_ejemplos (int): N√∫mero de ejemplos a mostrar por tipo de discordancia
        """
        print("üîç EJEMPLOS DE DISCORDANCIAS ENTRE M√âTODOS")
        print("=" * 70)
        
        # Encontrar discordancias
        discordantes = df[df['SentimientoPorCalificacion'] != df['SentimientoPorHF']].copy()
        
        if len(discordantes) == 0:
            print("‚úÖ No se encontraron discordancias entre los m√©todos")
            return
        
        print(f"üìä Total de discordancias: {len(discordantes)}/{len(df)} ({len(discordantes)/len(df)*100:.1f}%)")
        
        # Agrupar por tipo de discordancia
        tipos_discordancia = discordantes.groupby(['SentimientoPorCalificacion', 'SentimientoPorHF']).size()
        
        for (sent_cal, sent_hf), count in tipos_discordancia.items():
            print(f"\nüéØ {sent_cal} (Calificaci√≥n) ‚Üí {sent_hf} (HuggingFace): {count} casos")
            print("-" * 60)
            
            ejemplos = discordantes[
                (discordantes['SentimientoPorCalificacion'] == sent_cal) & 
                (discordantes['SentimientoPorHF'] == sent_hf)
            ].sample(n=min(n_ejemplos, count))
            
            for i, (idx, row) in enumerate(ejemplos.iterrows(), 1):
                print(f"\nüìå Ejemplo {i}:")
                print(f"   üèõÔ∏è Atracci√≥n: {row['Atraccion']}")
                print(f"   ‚≠ê Calificaci√≥n: {row['Calificacion']}/5 ‚Üí {row['SentimientoPorCalificacion']}")
                print(f"   ü§ñ HuggingFace: {row['SentimientoPorHF']}")
                print(f"   üí¨ Opini√≥n: \"{row['TituloReview']}\"")  # Texto completo sin cortar
                print("   " + "-" * 50)
    
    def mostrar_todas_discordancias(self, df: pd.DataFrame):
        """
        Muestra TODAS las opiniones discordantes completas organizadas por tipo.
        
        Args:
            df (pd.DataFrame): Dataset con ambas columnas de sentimiento
        """
        # Configurar pandas para mostrar texto completo
        pd.set_option('display.max_colwidth', None)
        pd.set_option('display.width', None)
        pd.set_option('display.max_columns', None)
        
        print("üìã LISTADO COMPLETO DE TODAS LAS DISCORDANCIAS")
        print("=" * 80)
        
        # Encontrar discordancias
        discordantes = df[df['SentimientoPorCalificacion'] != df['SentimientoPorHF']].copy()
        
        if len(discordantes) == 0:
            print("‚úÖ No se encontraron discordancias entre los m√©todos")
            return discordantes
        
        print(f"üìä Total de discordancias: {len(discordantes)}/{len(df)} ({len(discordantes)/len(df)*100:.1f}%)")
        
        # Agrupar por tipo de discordancia
        tipos_discordancia = discordantes.groupby(['SentimientoPorCalificacion', 'SentimientoPorHF']).size().sort_values(ascending=False)
        
        print(f"\nüìà Tipos de discordancia encontrados:")
        for (sent_cal, sent_hf), count in tipos_discordancia.items():
            porcentaje = (count / len(discordantes)) * 100
            print(f"   ‚Ä¢ {sent_cal} ‚Üí {sent_hf}: {count} casos ({porcentaje:.1f}%)")
        
        print("\n" + "=" * 80)
        print("üìÑ LISTADO DETALLADO DE TODAS LAS DISCORDANCIAS")
        print("=" * 80)
        
        # Mostrar todas las discordancias organizadas por tipo
        contador_global = 1
        for (sent_cal, sent_hf), count in tipos_discordancia.items():
            print(f"\nüéØ TIPO: {sent_cal} (‚≠êCalificaci√≥n) ‚Üí {sent_hf} (ü§ñHuggingFace)")
            print(f"üìä Total en esta categor√≠a: {count} casos")
            print("-" * 80)
            
            # Obtener todos los casos de este tipo
            casos = discordantes[
                (discordantes['SentimientoPorCalificacion'] == sent_cal) & 
                (discordantes['SentimientoPorHF'] == sent_hf)
            ].copy()
            
            # Ordenar por atracci√≥n para mejor organizaci√≥n
            casos = casos.sort_values('Atraccion')
            
            for idx, row in casos.iterrows():
                print(f"\n#{contador_global:03d} | {row['Atraccion']}")
                print(f"     ‚≠ê Calificaci√≥n: {row['Calificacion']}/5 ‚Üí {row['SentimientoPorCalificacion']}")
                print(f"     ü§ñ HuggingFace: {row['SentimientoPorHF']}")
                print(f"     üí¨ Opini√≥n completa:")
                print(f"     \"{row['TituloReview']}\"")
                print("     " + "‚îÄ" * 70)
                contador_global += 1
        
        print(f"\n‚úÖ An√°lisis completo: {contador_global-1} discordancias mostradas")
        
        # Resetear configuraci√≥n de pandas a valores por defecto
        pd.reset_option('display.max_colwidth')
        pd.reset_option('display.width') 
        pd.reset_option('display.max_columns')
        
        return discordantes
