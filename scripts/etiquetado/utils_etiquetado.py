"""
Utilidades y funciones de conveniencia para el etiquetado de subjetividad.
"""

import warnings


def configurar_entorno():
    """
    Configura el entorno de trabajo con las librer√≠as necesarias.
    """
    import matplotlib.pyplot as plt
    import seaborn as sns
    
    # Configuraci√≥n de visualizaci√≥n
    plt.style.use('seaborn-v0_8')
    sns.set_palette("husl")
    plt.rcParams['figure.figsize'] = (10, 6)
    plt.rcParams['font.size'] = 12
    
    # Suprimir warnings
    warnings.filterwarnings('ignore')


def mostrar_comandos_utiles():
    """
    Muestra los comandos √∫tiles disponibles en el m√≥dulo.
    """
    print("üí° COMANDOS √öTILES:")
    print("   ‚Ä¢ verificar_checkpoint() - Ver estado del progreso guardado")
    print("   ‚Ä¢ reiniciar_clasificacion() - Limpiar progreso y empezar de nuevo")
    print("   ‚Ä¢ limpiar_checkpoint() - Eliminar archivo de progreso")
    print("   ‚Ä¢ prueba_rapida(df_reviews, clasificador, n_samples=5) - Probar con pocas rese√±as")


def proceso_completo_clasificacion(df_reviews, clasificador, df_existente=None, batch_size=10, save_frequency=50):
    """
    Ejecuta el proceso completo de clasificaci√≥n con todas las etapas.
    
    Args:
        df_reviews (pandas.DataFrame): DataFrame con las rese√±as a clasificar
        clasificador: Clasificador configurado
        df_existente (pandas.DataFrame): DataFrame con clasificaciones previas (opcional)
        batch_size (int): Tama√±o del lote para mostrar progreso
        save_frequency (int): Frecuencia de guardado autom√°tico
        
    Returns:
        tuple: (df_clasificado_final, df_analizado, guardado_exitoso)
    """
    from .clasificador import clasificar_reviews, verificar_checkpoint
    from .analizador import analizar_resultados
    from .visualizador import crear_visualizaciones
    from .guardador import guardar_resultados, generar_resumen_final
    
    # Si no hay datos nuevos para clasificar, usar los existentes
    if df_reviews is None:
        if df_existente is not None:
            print("‚ÑπÔ∏è Usando datos existentes, no hay clasificaci√≥n nueva que hacer")
            df_analizado = analizar_resultados(df_existente)
            return df_existente, df_analizado, True
        else:
            print("‚ùå No hay datos para procesar")
            return None, None, False
    
    if clasificador is None:
        print("‚ùå No se puede proceder: falta configuraci√≥n del clasificador")
        return None, None, False
    
    print("üéØ Iniciando proceso de clasificaci√≥n...")
    if df_existente is not None:
        print(f" Se combinar√°n con {len(df_existente)} clasificaciones existentes")
    
    print("‚è±Ô∏è Esto puede tomar varios minutos...")
    print("üíæ El progreso se guarda autom√°ticamente")
    print("üõë Puedes interrumpir con Ctrl+C y el progreso se mantendr√°")
    print()
    
    # Verificar si hay checkpoint existente
    checkpoint_existe, _ = verificar_checkpoint()
    if checkpoint_existe:
        continuar = input("üîÑ ¬øQuieres continuar desde el √∫ltimo checkpoint? (s√≠/no): ")
        if continuar.lower() not in ['s√≠', 'si', 'yes', 'y']:
            from .clasificador import limpiar_checkpoint
            print("üóëÔ∏è Limpiando checkpoint para empezar desde el principio...")
            limpiar_checkpoint()
    
    try:
        # 1. Clasificar rese√±as nuevas
        print("üìã Paso 1: Clasificando rese√±as...")
        df_clasificado_nuevo = clasificar_reviews(df_reviews, clasificador, batch_size, save_frequency)
        
        if df_clasificado_nuevo is None:
            print("‚ùå Error en la clasificaci√≥n")
            return None, None, False
        
        # 2. Combinar con datos existentes si los hay
        print("\nÔøΩ Paso 2: Guardando y combinando resultados...")
        guardado_exitoso = guardar_resultados(df_clasificado_nuevo, df_existente)
        
        # Determinar el dataset final para an√°lisis
        if df_existente is not None:
            # Combinar para an√°lisis
            import pandas as pd
            df_final = pd.concat([df_existente, df_clasificado_nuevo], ignore_index=True)
            df_final = df_final.drop_duplicates(subset=['TituloReview'], keep='last')
        else:
            df_final = df_clasificado_nuevo
        
        # 3. Analizar resultados combinados
        print("\nÔøΩ Paso 3: Analizando resultados completos...")
        df_analizado = analizar_resultados(df_final)
        
        if df_analizado is None:
            print("‚ùå Error en el an√°lisis")
            return df_final, None, guardado_exitoso
        
        # 4. Crear visualizaciones
        print("\nÔøΩ Paso 4: Generando visualizaciones...")
        crear_visualizaciones(df_analizado)
        
        # 5. Generar resumen final
        print("\nüìã Paso 5: Generando resumen final...")
        generar_resumen_final(df_analizado)
        
        print("\nüéâ ¬°Proceso completo terminado exitosamente!")
        
        return df_final, df_analizado, guardado_exitoso
        
    except KeyboardInterrupt:
        print("\nüõë Proceso interrumpido por el usuario")
        print("üíæ El progreso ha sido guardado. Ejecuta nuevamente para continuar.")
        return None, None, False
        
    except Exception as e:
        print(f"\n‚ùå Error inesperado: {e}")
        print("üíæ Verificando si se guard√≥ progreso...")
        verificar_checkpoint()
        return None, None, False


def validar_dependencias():
    """
    Valida que todas las dependencias necesarias est√©n instaladas.
    
    Returns:
        bool: True si todas las dependencias est√°n disponibles
    """
    dependencias = [
        ('pandas', 'pd'),
        ('numpy', 'np'),
        ('matplotlib.pyplot', 'plt'),
        ('seaborn', 'sns'),
        ('langchain_openai', None),
        ('langchain_core.output_parsers', None),
        ('langchain_core.prompts', None),
        ('pydantic', None),
        ('tqdm', None),
        ('dotenv', None)
    ]
    
    faltantes = []
    
    for dep, alias in dependencias:
        try:
            if alias:
                exec(f"import {dep} as {alias}")
            else:
                exec(f"import {dep}")
        except ImportError:
            faltantes.append(dep)
    
    if faltantes:
        print("‚ùå Faltan las siguientes dependencias:")
        for dep in faltantes:
            print(f"   ‚Ä¢ {dep}")
        print("\nInst√°lalas con: pip install [nombre_dependencia]")
        return False
    else:
        return True


def obtener_info_sistema():
    """
    Obtiene informaci√≥n del sistema para debugging.
    """
    import sys
    import platform
    
    print("üîß INFORMACI√ìN DEL SISTEMA:")
    print(f"   ‚Ä¢ Python: {sys.version}")
    print(f"   ‚Ä¢ Plataforma: {platform.system()} {platform.release()}")
    print(f"   ‚Ä¢ Arquitectura: {platform.machine()}")
    
    try:
        import pandas as pd
        print(f"   ‚Ä¢ Pandas: {pd.__version__}")
    except:
        print("   ‚Ä¢ Pandas: No disponible")
    
    try:
        import numpy as np
        print(f"   ‚Ä¢ NumPy: {np.__version__}")
    except:
        print("   ‚Ä¢ NumPy: No disponible")
    
    try:
        import matplotlib
        print(f"   ‚Ä¢ Matplotlib: {matplotlib.__version__}")
    except:
        print("   ‚Ä¢ Matplotlib: No disponible")
