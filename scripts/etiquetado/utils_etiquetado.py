"""
Utilidades y funciones de conveniencia para el etiquetado de subjetividad.
"""

import warnings


def configurar_entorno():
    """
    Configura el entorno de trabajo con las librer√≠as necesarias.
    """
    import matplotlib.pyplot as plt
    import seaborn as sns
    
    # Configuraci√≥n de visualizaci√≥n
    plt.style.use('seaborn-v0_8')
    sns.set_palette("husl")
    plt.rcParams['figure.figsize'] = (10, 6)
    plt.rcParams['font.size'] = 12
    
    # Suprimir warnings
    warnings.filterwarnings('ignore')


def mostrar_comandos_utiles():
    """
    Muestra los comandos √∫tiles disponibles en el m√≥dulo.
    """
    print("üí° COMANDOS √öTILES:")
    print("   ‚Ä¢ verificar_checkpoint() - Ver estado del progreso guardado")
    print("   ‚Ä¢ reiniciar_clasificacion() - Limpiar progreso y empezar de nuevo")
    print("   ‚Ä¢ limpiar_checkpoint() - Eliminar archivo de progreso")
    print("   ‚Ä¢ prueba_rapida(df_reviews, clasificador, n_samples=5) - Probar con pocas rese√±as")


def proceso_completo_clasificacion(df_reviews, clasificador, df_existente=None, batch_size=10, save_frequency=50):
    """
    Ejecuta el proceso completo de clasificaci√≥n con todas las etapas.
    
    Args:
        df_reviews (pandas.DataFrame): DataFrame con las rese√±as a clasificar
        clasificador: Clasificador configurado
        df_existente (pandas.DataFrame): DataFrame con clasificaciones previas (opcional)
        batch_size (int): Tama√±o del lote para mostrar progreso
        save_frequency (int): Frecuencia de guardado autom√°tico
        
    Returns:
        tuple: (df_clasificado_final, df_analizado, guardado_exitoso)
    """
    from .clasificador import clasificar_reviews
    from .analizador import analizar_resultados
    from .visualizador import crear_visualizaciones
    from .guardador import guardar_resultados, generar_resumen_final
    
    # Si no hay datos nuevos para clasificar, usar los existentes
    if df_reviews is None:
        if df_existente is not None:
            df_analizado = analizar_resultados(df_existente)
            return df_existente, df_analizado, True
        else:
            return None, None, False
    
    if clasificador is None:
        return None, None, False
    
    try:
        # 1. Clasificar rese√±as nuevas (SOLO maneja checkpoint, NO guarda CSV)
        df_clasificado_nuevo = clasificar_reviews(df_reviews, clasificador, batch_size, save_frequency)
        
        if df_clasificado_nuevo is None:
            return None, None, False
        
        # 2. Solo guardar al CSV si la clasificaci√≥n est√° 100% completa
        # Verificar que no haya interrupciones y que todos los datos est√©n procesados
        if len(df_clasificado_nuevo) == len(df_reviews):
            print("\nüéØ Clasificaci√≥n completada exitosamente")
            print("üíæ Procediendo a guardar en el dataset final...")
            guardado_exitoso = guardar_resultados(df_clasificado_nuevo, df_existente)
        else:
            print(f"\n‚ö†Ô∏è Clasificaci√≥n incompleta: {len(df_clasificado_nuevo)}/{len(df_reviews)} procesadas")
            print("üíæ Los datos parciales est√°n guardados en checkpoint")
            print("üîÑ Ejecute nuevamente para continuar desde donde se qued√≥")
            guardado_exitoso = False
        
        # Determinar el dataset final para an√°lisis
        if df_existente is not None:
            # Combinar para an√°lisis
            import pandas as pd
            df_final = pd.concat([df_existente, df_clasificado_nuevo], ignore_index=True)
            df_final = df_final.drop_duplicates(subset=['TituloReview'], keep='last')
        else:
            df_final = df_clasificado_nuevo
        
        # 3. Analizar resultados combinados
        df_analizado = analizar_resultados(df_final)
        
        if df_analizado is None:
            return df_final, None, guardado_exitoso
        
        # 4. Crear visualizaciones
        crear_visualizaciones(df_analizado)
        
        # 5. Generar resumen final
        generar_resumen_final(df_analizado)
        
        return df_final, df_analizado, guardado_exitoso
        
    except KeyboardInterrupt:
        print("\nüõë Proceso interrumpido por el usuario")
        print("üíæ Los datos parciales est√°n guardados en checkpoint")
        print("üîÑ Para continuar desde donde se qued√≥, ejecute nuevamente la clasificaci√≥n")
        print("üìã Para verificar el progreso, use: verificar_checkpoint()")
        return None, None, False
        
    except Exception as e:
        print(f"\n‚ùå Error inesperado: {e}")
        print("üíæ Revise si hay datos guardados en checkpoint con: verificar_checkpoint()")
        return None, None, False


def validar_dependencias():
    """
    Valida que todas las dependencias necesarias est√©n instaladas.
    
    Returns:
        bool: True si todas las dependencias est√°n disponibles
    """
    dependencias = [
        ('pandas', 'pd'),
        ('numpy', 'np'),
        ('matplotlib.pyplot', 'plt'),
        ('seaborn', 'sns'),
        ('langchain_openai', None),
        ('langchain_core.output_parsers', None),
        ('langchain_core.prompts', None),
        ('pydantic', None),
        ('tqdm', None),
        ('dotenv', None)
    ]
    
    faltantes = []
    
    for dep, alias in dependencias:
        try:
            if alias:
                exec(f"import {dep} as {alias}")
            else:
                exec(f"import {dep}")
        except ImportError:
            faltantes.append(dep)
    
    if faltantes:
        print(f"‚ùå Faltan dependencias: {', '.join(faltantes)}")
        return False
    return True


def obtener_info_sistema():
    """
    Obtiene informaci√≥n del sistema para debugging.
    """
    import sys
    import platform
    
    print("üîß INFORMACI√ìN DEL SISTEMA:")
    print(f"   ‚Ä¢ Python: {sys.version}")
    print(f"   ‚Ä¢ Plataforma: {platform.system()} {platform.release()}")
    print(f"   ‚Ä¢ Arquitectura: {platform.machine()}")
    
    try:
        import pandas as pd
        print(f"   ‚Ä¢ Pandas: {pd.__version__}")
    except:
        print("   ‚Ä¢ Pandas: No disponible")
    
    try:
        import numpy as np
        print(f"   ‚Ä¢ NumPy: {np.__version__}")
    except:
        print("   ‚Ä¢ NumPy: No disponible")
    
    try:
        import matplotlib
        print(f"   ‚Ä¢ Matplotlib: {matplotlib.__version__}")
    except:
        print("   ‚Ä¢ Matplotlib: No disponible")
