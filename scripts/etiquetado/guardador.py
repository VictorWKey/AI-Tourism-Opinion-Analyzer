"""
M√≥dulo para guardar resultados y generar res√∫menes finales.
"""

import pandas as pd


def guardar_resultados(df_clasificado, df_existente=None, ruta_salida="../data/processed/reviews_clasificadas_subjetividad.csv"):
    """
    Guarda los resultados clasificados en un archivo CSV.
    Si hay datos existentes, los combina inteligentemente.
    
    Args:
        df_clasificado (pandas.DataFrame): DataFrame con las nuevas clasificaciones
        df_existente (pandas.DataFrame): DataFrame con clasificaciones previas (opcional)
        ruta_salida (str): Ruta donde guardar el archivo
        
    Returns:
        bool: True si el guardado fue exitoso, False en caso contrario
    """
    if df_clasificado is None:
        if df_existente is not None:
            print("‚ÑπÔ∏è No hay nuevas clasificaciones, manteniendo datos existentes")
            return True
        else:
            print("‚ùå No hay datos para guardar")
            return False
    
    try:
        # Si hay datos existentes, combinar inteligentemente
        if df_existente is not None and len(df_existente) > 0:
            print("üîÑ Combinando nuevas clasificaciones con datos existentes...")
            
            # Crear copia de datos existentes
            df_final = df_existente.copy()
            
            # Agregar nuevas clasificaciones
            df_final = pd.concat([df_final, df_clasificado], ignore_index=True)
            
            # Eliminar duplicados basados en TituloReview, manteniendo la √∫ltima clasificaci√≥n
            df_final = df_final.drop_duplicates(subset=['TituloReview'], keep='last')
            
            print(f"üìä Datos combinados: {len(df_existente)} existentes + {len(df_clasificado)} nuevas = {len(df_final)} total")
        else:
            df_final = df_clasificado.copy()
        
        # Guardar el dataset combinado
        df_final.to_csv(ruta_salida, index=False, encoding='utf-8')
        
        print(f"‚úÖ Resultados guardados en: {ruta_salida}")
        print(f"üìÑ Archivo contiene {len(df_final)} rese√±as clasificadas")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Error al guardar resultados: {e}")
        return False


def generar_resumen_final(df_clean):
    """
    Genera un resumen final del proceso de clasificaci√≥n.
    
    Args:
        df_clean (pandas.DataFrame): DataFrame limpio con clasificaciones v√°lidas
    """
    if df_clean is None:
        print("‚ùå No hay datos para resumir")
        return
    
    print("üéØ RESUMEN FINAL DEL PROCESO DE CLASIFICACI√ìN")
    print("=" * 60)
    
    # Estad√≠sticas generales
    total_reviews = len(df_clean)
    conteo = df_clean['Clasificacion_Subjetividad'].value_counts()
    
    print(f"üìä Total de rese√±as procesadas: {total_reviews}")
    print()
    
    print("üè∑Ô∏è RESULTADOS DE CLASIFICACI√ìN:")
    for categoria in ['Objetiva', 'Subjetiva', 'Mixta']:
        if categoria in conteo:
            count = conteo[categoria]
            percentage = (count / total_reviews) * 100
            print(f"   {categoria:10}: {count:4d} rese√±as ({percentage:5.1f}%)")
    print()
    
    # Insights principales
    categoria_predominante = conteo.index[0]
    porcentaje_predominante = (conteo.iloc[0] / total_reviews) * 100
    
    print("üîç INSIGHTS PRINCIPALES:")
    print(f"   ‚Ä¢ La categor√≠a predominante es '{categoria_predominante}' con {porcentaje_predominante:.1f}% del total")
    
    if categoria_predominante == 'Subjetiva':
        print("   ‚Ä¢ Las rese√±as tur√≠sticas tienden a ser principalmente subjetivas (opiniones y sentimientos)")
    elif categoria_predominante == 'Objetiva':
        print("   ‚Ä¢ Las rese√±as tur√≠sticas tienden a ser principalmente objetivas (hechos verificables)")
    else:
        print("   ‚Ä¢ Las rese√±as tur√≠sticas tienden a combinar hechos con opiniones (mixtas)")
    
    # Comparaci√≥n por ciudad
    print("\nüåé COMPARACI√ìN POR CIUDAD:")
    for ciudad in df_clean['Ciudad'].unique():
        df_ciudad = df_clean[df_clean['Ciudad'] == ciudad]
        conteo_ciudad = df_ciudad['Clasificacion_Subjetividad'].value_counts()
        categoria_ciudad = conteo_ciudad.index[0]
        porcentaje_ciudad = (conteo_ciudad.iloc[0] / len(df_ciudad)) * 100
        
        print(f"   üìç {ciudad}: Predomina '{categoria_ciudad}' ({porcentaje_ciudad:.1f}%)")
    
    print("\n‚úÖ Proceso de clasificaci√≥n completado exitosamente")


def generar_reporte_completo(df_clasificado, df_clean, ruta_reporte="../data/processed/reporte_clasificacion.txt"):
    """
    Genera un reporte completo del proceso de clasificaci√≥n en formato texto.
    
    Args:
        df_clasificado (pandas.DataFrame): DataFrame con todas las clasificaciones
        df_clean (pandas.DataFrame): DataFrame limpio sin errores
        ruta_reporte (str): Ruta donde guardar el reporte
        
    Returns:
        bool: True si el reporte se gener√≥ exitosamente
    """
    if df_clasificado is None or df_clean is None:
        print("‚ùå No hay datos suficientes para generar el reporte")
        return False
    
    try:
        with open(ruta_reporte, 'w', encoding='utf-8') as f:
            f.write("REPORTE DE CLASIFICACI√ìN DE SUBJETIVIDAD\n")
            f.write("=" * 50 + "\n\n")
            
            # Informaci√≥n general
            f.write(f"Total de rese√±as procesadas: {len(df_clasificado)}\n")
            f.write(f"Rese√±as clasificadas exitosamente: {len(df_clean)}\n")
            f.write(f"Rese√±as con errores: {len(df_clasificado) - len(df_clean)}\n\n")
            
            # Distribuci√≥n general
            conteo = df_clean['Clasificacion_Subjetividad'].value_counts()
            f.write("DISTRIBUCI√ìN GENERAL:\n")
            for categoria in ['Objetiva', 'Subjetiva', 'Mixta']:
                if categoria in conteo:
                    count = conteo[categoria]
                    pct = (count / len(df_clean)) * 100
                    f.write(f"  {categoria}: {count} rese√±as ({pct:.1f}%)\n")
            f.write("\n")
            
            # Distribuci√≥n por ciudad
            f.write("DISTRIBUCI√ìN POR CIUDAD:\n")
            for ciudad in df_clean['Ciudad'].unique():
                f.write(f"\n{ciudad}:\n")
                df_ciudad = df_clean[df_clean['Ciudad'] == ciudad]
                conteo_ciudad = df_ciudad['Clasificacion_Subjetividad'].value_counts()
                
                for categoria in ['Objetiva', 'Subjetiva', 'Mixta']:
                    if categoria in conteo_ciudad:
                        count = conteo_ciudad[categoria]
                        pct = (count / len(df_ciudad)) * 100
                        f.write(f"  {categoria}: {count} rese√±as ({pct:.1f}%)\n")
            
            # Ejemplos de cada categor√≠a
            f.write("\n\nEJEMPLOS POR CATEGOR√çA:\n")
            for categoria in ['Objetiva', 'Subjetiva', 'Mixta']:
                f.write(f"\n{categoria.upper()}:\n")
                ejemplos = df_clean[df_clean['Clasificacion_Subjetividad'] == categoria]['TituloReview'].head(5)
                for i, ejemplo in enumerate(ejemplos, 1):
                    f.write(f"  {i}. {ejemplo}\n")
        
        print(f"‚úÖ Reporte completo guardado en: {ruta_reporte}")
        return True
        
    except Exception as e:
        print(f"‚ùå Error al generar reporte: {e}")
        return False


def exportar_estadisticas_json(df_clean, ruta_json="../data/processed/estadisticas_clasificacion.json"):
    """
    Exporta las estad√≠sticas de clasificaci√≥n en formato JSON.
    
    Args:
        df_clean (pandas.DataFrame): DataFrame limpio con clasificaciones
        ruta_json (str): Ruta donde guardar el archivo JSON
        
    Returns:
        bool: True si la exportaci√≥n fue exitosa
    """
    import json
    from datetime import datetime
    
    if df_clean is None:
        print("‚ùå No hay datos para exportar")
        return False
    
    try:
        # Generar estad√≠sticas
        conteo_general = df_clean['Clasificacion_Subjetividad'].value_counts()
        porcentaje_general = df_clean['Clasificacion_Subjetividad'].value_counts(normalize=True) * 100
        
        estadisticas = {
            'timestamp': datetime.now().isoformat(),
            'total_reviews': len(df_clean),
            'distribucion_general': {
                'conteo': conteo_general.to_dict(),
                'porcentaje': porcentaje_general.to_dict()
            },
            'categoria_predominante': conteo_general.index[0],
            'distribucion_por_ciudad': {}
        }
        
        # Estad√≠sticas por ciudad
        for ciudad in df_clean['Ciudad'].unique():
            df_ciudad = df_clean[df_clean['Ciudad'] == ciudad]
            conteo_ciudad = df_ciudad['Clasificacion_Subjetividad'].value_counts()
            porcentaje_ciudad = df_ciudad['Clasificacion_Subjetividad'].value_counts(normalize=True) * 100
            
            estadisticas['distribucion_por_ciudad'][ciudad] = {
                'total': len(df_ciudad),
                'conteo': conteo_ciudad.to_dict(),
                'porcentaje': porcentaje_ciudad.to_dict(),
                'categoria_predominante': conteo_ciudad.index[0]
            }
        
        # Guardar en JSON
        with open(ruta_json, 'w', encoding='utf-8') as f:
            json.dump(estadisticas, f, indent=2, ensure_ascii=False)
        
        print(f"‚úÖ Estad√≠sticas exportadas a: {ruta_json}")
        return True
        
    except Exception as e:
        print(f"‚ùå Error al exportar estad√≠sticas: {e}")
        return False
